```Cucumber 
1 a * - / _ "B" = == # :: 
```
```abap 
1 a * - / _ "B" = == # :: 
```
```ada 
1 a * - / _ "B" = == # :: 
```
```ahk 
1 a * - / _ "B" = == # :: 
```
```apacheconf 
1 a * - / _ "B" = == # :: 
```
```applescript 
1 a * - / _ "B" = == # :: 
```
```as 
1 a * - / _ "B" = == # :: 
```
```as3 
1 a * - / _ "B" = == # :: 
```
```asy 
1 a * - / _ "B" = == # :: 
```
```bash 
1 a * - / _ "B" = == # :: 
```
```bat 
1 a * - / _ "B" = == # :: 
```
```befunge 
1 a * - / _ "B" = == # :: 
```
```blitzmax 
1 a * - / _ "B" = == # :: 
```
```boo 
1 a * - / _ "B" = == # :: 
```
```brainfuck 
1 a * - / _ "B" = == # :: 
```
```c 
1 a * - / _ "B" = == # :: 
```
```cfm 
1 a * - / _ "B" = == # :: 
```
```cheetah 
111 a * - / _ "B" = == # :: 
```
```cl
1 a * - / _ "B" = == # :: 
```
```clojure
1 a * - / _ "B" = == # :: 
```
```cmake
1 a * - / _ "B" = == # :: 
```
```coffeescript
2 a * - / _ "B" = == # :: 
```
```console
1 a * - / _ "B" = == # :: 
```
```control
1 a * - / _ "B" = == # :: 
```
```cpp
1 a * - / _ "B" = == # :: 
```
```csharp
1 a * - / _ "B" = == # :: 
```
```css
1 a * - / _ "B" = == # :: 
```
```cython
1 a * - / _ "B" = == # :: 
```
```d
1 a * - / _ "B" = == # :: 
```
```delphi
1 a * - / _ "B" = == # :: 
```
```diff
1 a * - / _ "B" = == # :: 
```
```dpatch
1 a * - / _ "B" = == # :: 
```
```duel
1 a * - / _ "B" = == # :: 
```
```dylan
1 a * - / _ "B" = == # :: 
```
```erb
1 a * - / _ "B" = == # :: 
```
```erl
1 a * - / _ "B" = == # :: 
```
```erlang
1 a * - / _ "B" = == # :: 
```
```evoque
1 a * - / _ "B" = == # :: 
```
```factor
1 a * - / _ "B" = == # :: 
```
```felix
1 a * - / _ "B" = == # :: 
```
```fortran
1 a * - / _ "B" = == # :: 
```
```gas
1 a * - / _ "B" = == # :: 
```
```genshi
1 a * - / _ "B" = == # :: 
```
```glsl
1 a * - / _ "B" = == # :: 
```
```gnuplot
1 a * - / _ "B" = == # :: 
```
```go
1 a * - / _ "B" = == # :: 
```
```groff
1 a * - / _ "B" = == # :: 
```
```haml
1 a * - / _ "B" = == # :: 
```
```haskell
1 a * - / _ "B" = == # :: 
```
```html
1 a * - / _ "B" = == # :: 
```
```hx
1 a * - / _ "B" = == # :: 
```
```hybris
1 a * - / _ "B" = == # :: 
```
```ini
1 a * - / _ "B" = == # :: 
```
```io
1 a * - / _ "B" = == # :: 
```
```ioke
1 a * - / _ "B" = == # :: 
```
```irc
1 a * - / _ "B" = == # :: 
```
```jade
1 a * - / _ "B" = == # :: 
```
```java
1 a * - / _ "B" = == # :: 
```
```js
1 a * - / _ "B" = == # :: 
```
```jsp
1 a * - / _ "B" = == # :: 
```
```lhs
1 a * - / _ "B" = == # :: 
```
```llvm
1 a * - / _ "B" = == # :: 
```
```logtalk
1 a * - / _ "B" = == # :: 
```
```lua
1 a * - / _ "B" = == # :: 
```
```make
1 a * - / _ "B" = == # :: 
```
```mako
1 a * - / _ "B" = == # :: 
```
```maql
1 a * - / _ "B" = == # :: 
```
```mason
1 a * - / _ "B" = == # :: 
```
```markdown
1 a * - / _ "B" = == # :: 
```
```modelica
1 a * - / _ "B" = == # :: 
```
```modula2
1 a * - / _ "B" = == # :: 
```
```moocode
1 a * - / _ "B" = == # :: 
```
```mupad
1 a * - / _ "B" = == # :: 
```
```mxml
1 a * - / _ "B" = == # :: 
```
```myghty
1 a * - / _ "B" = == # :: 
```
```nasm
1 a * - / _ "B" = == # :: 
```
```newspeak
1 a * - / _ "B" = == # :: 
```
```objdump
1 a * - / _ "B" = == # :: 
```
```objectivec
1 a * - / _ "B" = == # :: 
```
```objectivej
1 a * - / _ "B" = == # :: 
```
```ocaml
1 a * - / _ "B" = == # :: 
```
```ooc
1 a * - / _ "B" = == # :: 
```
```perl
1 a * - / _ "B" = == # :: 
```
```php
1 a * - / _ "B" = == # :: 
```
```postscript
1 a * - / _ "B" = == # :: 
```
```pot
1 a * - / _ "B" = == # :: 
```
```pov
1 a * - / _ "B" = == # :: 
```
```prolog
1 a * - / _ "B" = == # :: 
```
```properties
1 a * - / _ "B" = == # :: 
```
```protobuf
1 a * - / _ "B" = == # :: 
```
```py3tb
1 a * - / _ "B" = == # :: 
```
```pytb
1 a * - / _ "B" = == # :: 
```
```python
1 a * - / _ "B" = == # :: 
```
```r
1 a * - / _ "B" = == # :: 
```
```rb
1 a * - / _ "B" = == # :: 
```
```rconsole
1 a * - / _ "B" = == # :: 
```
```rebol
1 a * - / _ "B" = == # :: 
```
```redcode
1 a * - / _ "B" = == # :: 
```
```rhtml
1 a * - / _ "B" = == # :: 
```
```rst
1 a * - / _ "B" = == # :: 
```
```sass
1 a * - / _ "B" = == # :: 
```
```scala
1 a * - / _ "B" = == # :: 
```
```scaml
1 a * - / _ "B" = == # :: 
```
```scheme
1 a * - / _ "B" = == # :: 
```
```scss
1 a * - / _ "B" = == # :: 
```
```smalltalk
1 a * - / _ "B" = == # :: 
```
```smarty
1 a * - / _ "B" = == # :: 
```
```sourceslist
1 a * - / _ "B" = == # :: 
```
```splus
1 a * - / _ "B" = == # :: 
```
```sql
1 a * - / _ "B" = == # :: 
```
```sqlite3
1 a * - / _ "B" = == # :: 
```
```squidconf
1 a * - / _ "B" = == # :: 
```
```ssp
1 a * - / _ "B" = == # :: 
```
```tcl
1 a * - / _ "B" = == # :: 
```
```tcsh
1 a * - / _ "B" = == # :: 
```
```tex
1 a * - / _ "B" = == # :: 
```
```text
1 a * - / _ "B" = == # :: 
```
```v
1 a * - / _ "B" = == # :: 
```
```vala
1 a * - / _ "B" = == # :: 
```
```vbnet
1 a * - / _ "B" = == # :: 
```
```velocity
1 a * - / _ "B" = == # :: 
```
```vim
1 a * - / _ "B" = == # :: 
```
```xml
1 a * - / _ "B" = == # :: 
```
```xquery
1 a * - / _ "B" = == # :: 
```
```xslt
1 a * - / _ "B" = == # :: 
```
```yaml
1 a * - / _ "B" = == # :: 
```


# zax-tensor
Yet another tensor library in C++. It allows direct access to its underlying data buffer, and serializes in JSON. Built on top of zax json parser, C++ structures having tensor members can also be JSON-serialized and deserialized, allowing one to save and load the state of a highly hierarchical object.

```cpp

#include <iostream>
#include <typeinfo>
#include <string>
#include <string.h>
#include <map>
#include <vector>
#include <numeric>
#include "ZaxJsonParser.h"
#include "ZaxTensor.h"

int main()
{
    ZaxJsonParser::set_indent(4);
    tensor_f32 t_2d = R"([[81,90],
                          [0,2],
                          [-1,3]])";
    std::cout << t_2d;
    return 0;
}

```
#### Result:

```cpp

[
    [81.000000,90.000000],
    [0.000000,2.000000],
    [-1.000000,3.000000]]

```
# examples:
#### Example1 - create 3d tensor by shape:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 t_f32({2,3,4});
    std::cout << t_f32;

```
##### Result:

```cpp

[
    [
        [0.000000,0.000000,0.000000,0.000000],
        [0.000000,0.000000,0.000000,0.000000],
        [0.000000,0.000000,0.000000,0.000000]],
    [
        [0.000000,0.000000,0.000000,0.000000],
        [0.000000,0.000000,0.000000,0.000000],
        [0.000000,0.000000,0.000000,0.000000]]]

```

#### Example2 - display shape of a tensor:

##### Code:

```cpp

    tensor_f32 t_f32({2,3,4});
    std::vector<int> s = t_f32.shape();
    std::cout << s[0] << "/" << s[1] << "/" << s[2] << std::endl;
    std::cout << t_f32.shape_s();

```
##### Result:

```cpp

2/3/4
{2,3,4}

```

#### Example3 - accessing an element of a 3d tensor:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_i32 tensor_i32_({2,3,4});
    std::cout << tensor_i32_ << std::endl << std::endl;
    (*tensor_i32_.m_3d)[1][1][1] = 5;
    std::cout << tensor_i32_;

```
##### Result:

```cpp

[
    [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]],
    [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]]]

[
    [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]],
    [
        [0,0,0,0],
        [0,5,0,0],
        [0,0,0,0]]]

```
#### Example4 - 4d data buffer access of a 4d tensor:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 _4d({2,2,2,3});
    float**** b = _4d.data_4d();
    int c = 0;
    for (int i = 0; i < _4d.m_4d->d1; ++i)
        for (int j = 0; j < _4d.m_4d->d2; ++j)
            for (int k = 0; k < _4d.m_4d->d3; ++k)
                for (int l = 0; l < _4d.m_4d->d4; ++l)
                    b[i][j][k][l] = c++;
    std::cout << _4d;

```
##### Result:

```cpp

[
    [
        [
            [0.000000,1.000000,2.000000],
            [3.000000,4.000000,5.000000]],
        [
            [6.000000,7.000000,8.000000],
            [9.000000,10.000000,11.000000]]],
    [
        [
            [12.000000,13.000000,14.000000],
            [15.000000,16.000000,17.000000]],
        [
            [18.000000,19.000000,20.000000],
            [21.000000,22.000000,23.000000]]]]

```
#### Example5 - 1d data buffer access of a 4d tensor:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 _4d({2,2,2,3});
    float* b = _4d.data();
    for (int i = 0; i < _4d.numel(); ++i)
        b[i] = i;
    std::cout << _4d;

```
##### Result:

```cpp

[
    [
        [
            [0.000000,1.000000,2.000000],
            [3.000000,4.000000,5.000000]],
        [
            [6.000000,7.000000,8.000000],
            [9.000000,10.000000,11.000000]]],
    [
        [
            [12.000000,13.000000,14.000000],
            [15.000000,16.000000,17.000000]],
        [
            [18.000000,19.000000,20.000000],
            [21.000000,22.000000,23.000000]]]]

```
#### Example6 -reshape a 4d tensor to a 4d tensor with different dimensions:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 _4d = R"([
    [
        [
            [1,2,3],
            [4,5,6]],
        [
            [7,8,9],
            [10,11,12]]],
    [
        [
            [13,14,15],
            [16,17,18]],
        [
            [19,20,21],
            [22,23,24]]]])";
    std::cout << _4d << std::endl << std::endl;
    _4d.reshape(2,6,1,2);
    std::cout << _4d << std::endl << std::endl;

```
##### Result:

```cpp

[
    [
        [
            [1.000000,2.000000,3.000000],
            [4.000000,5.000000,6.000000]],
        [
            [7.000000,8.000000,9.000000],
            [10.000000,11.000000,12.000000]]],
    [
        [
            [13.000000,14.000000,15.000000],
            [16.000000,17.000000,18.000000]],
        [
            [19.000000,20.000000,21.000000],
            [22.000000,23.000000,24.000000]]]]

[
    [
        [
            [1.000000,2.000000]],
        [
            [3.000000,4.000000]],
        [
            [5.000000,6.000000]],
        [
            [7.000000,8.000000]],
        [
            [9.000000,10.000000]],
        [
            [11.000000,12.000000]]],
    [
        [
            [13.000000,14.000000]],
        [
            [15.000000,16.000000]],
        [
            [17.000000,18.000000]],
        [
            [19.000000,20.000000]],
        [
            [21.000000,22.000000]],
        [
            [23.000000,24.000000]]]]
```

#### Example7 -reshape a 4d tensor to a 3d tensor with same number of elements:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 _4d = R"([
    [
        [
            [1,2,3],
            [4,5,6]],
        [
            [7,8,9],
            [10,11,12]]],
    [
        [
            [13,14,15],
            [16,17,18]],
        [
            [19,20,21],
            [22,23,24]]]])";
    std::cout << _4d << std::endl << std::endl;
    _4d.reshape(2,6,1,2);
    std::cout << _4d << std::endl << std::endl;

```
##### Result:

```cpp

[
    [
        [
            [1.000000,2.000000,3.000000],
            [4.000000,5.000000,6.000000]],
        [
            [7.000000,8.000000,9.000000],
            [10.000000,11.000000,12.000000]]],
    [
        [
            [13.000000,14.000000,15.000000],
            [16.000000,17.000000,18.000000]],
        [
            [19.000000,20.000000,21.000000],
            [22.000000,23.000000,24.000000]]]]

[
    [
        [1.000000,2.000000,3.000000,4.000000,5.000000,6.000000],
        [7.000000,8.000000,9.000000,10.000000,11.000000,12.000000]],
    [
        [13.000000,14.000000,15.000000,16.000000,17.000000,18.000000],
        [19.000000,20.000000,21.000000,22.000000,23.000000,24.000000]]]
       
```
#### Example8 - create a 2d view of a 2d tensor with different shapes but same number of elements:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 t_2d = R"([[0,1],
                          [2,3],
                          [4,5]])";
    tensor_f32 t_2d_view;
    t_2d_view.view({1, 6}, t_2d);
    (*t_2d_view.m_2d)[0][3] = 99;
    std::cout << t_2d << std::endl << std::endl;
    std::cout << t_2d_view;

```
##### Result:

```cpp

[
    [0.000000,1.000000],
    [2.000000,99.000000],
    [4.000000,5.000000]]

[
    [0.000000,1.000000,2.000000,99.000000,4.000000,5.000000]]

```
#### Example9 - create a 1d view of a 2d tensor with same number of elements:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 t_2d = R"([[0,1],
                          [2,3],
                          [4,5]])";
    tensor_f32 t_2d_view;
    t_2d_view.view({6}, t_2d);
    (*t_2d_view.m_2d)[3] = 99;
    std::cout << t_2d << std::endl << std::endl;
    std::cout << t_2d_view;

```
##### Result:

```cpp

[
    [0.000000,1.000000],
    [2.000000,99.000000],
    [4.000000,5.000000]]

[0.000000,1.000000,2.000000,99.000000,4.000000,5.000000]

```
#### Example10 - squeeze and unsqueeze:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    tensor_f32 t_f32({1,3,3});
    std::cout << t_f32 << std::endl << std::endl;
    t_f32.squeeze(0);
    std::cout << t_f32 << std::endl << std::endl;
    t_f32.unsqueeze(0).unsqueeze(0);
    std::cout << t_f32 << std::endl << std::endl;

```
##### Result:

```cpp

[
    [
        [0.000000,0.000000,0.000000],
        [0.000000,0.000000,0.000000],
        [0.000000,0.000000,0.000000]]]

[
    [0.000000,0.000000,0.000000],
    [0.000000,0.000000,0.000000],
    [0.000000,0.000000,0.000000]]

[
    [
        [
            [0.000000,0.000000,0.000000],
            [0.000000,0.000000,0.000000],
            [0.000000,0.000000,0.000000]]]]

```
#### Example11 - array of tensors:

##### Code:

```cpp

    ZaxJsonParser::set_indent(4);
    array_of_tensor_f32 aot = R"([[81,90,0],
                                  [[0,2],[5,6],[7,8]],
                                  [-1,0,3,0,9]])";
    std::cout << aot;

```
##### Result:

```cpp

[[81.000000,90.000000,0.000000],
    [
        [0.000000,2.000000],
        [5.000000,6.000000],
        [7.000000,8.000000]],
    [-1.000000,0.000000,3.000000,0.000000,9.000000]]

```
#### Example12 - serialization of a class containing tensors:

##### Code:

```cpp

    struct some_class
    {
        tensor_f32 t_1d = R"([1,2,3])";
        tensor_f32 t_2d = R"([[1,2], [3,4], [5,6]])";
        ZAX_JSON_SERIALIZABLE(some_class, JSON_PROPERTY(t_1d), JSON_PROPERTY(t_2d))
    };

    ZaxJsonParser::set_indent(4);
    some_class some_obj;
    std::cout << some_obj;

```
##### Result:

```cpp

{
    "t_1d":[1.000000,2.000000,3.000000],
    "t_2d":[
        [1.000000,2.000000],
        [3.000000,4.000000],
        [5.000000,6.000000]]
}

```
